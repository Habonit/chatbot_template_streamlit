# Phase 01 - UI/UX 개선 요구사항

이 문서는 Gemini Hybrid Chatbot의 사용자 경험 개선을 위한 구체적인 요구사항을 정의합니다.

---

## 1. PDF 전처리 진행 상태 표시 개선

### 1.1 현재 상태
- PDF 전처리 시 `st.progress`를 사용한 진행률 표시는 구현되어 있음
- 단계별 상태 메시지("텍스트 추출 중...", "청킹 중...", "정규화 중...", "임베딩 생성 중...")는 표시됨
- **문제점**: 예상 소요 시간 정보가 없어 사용자가 얼마나 기다려야 할지 알 수 없음

### 1.2 개선 요구사항

#### 1.2.1 예상 소요 시간 계산 및 표시
- **위치**: PDF Preprocessing 탭의 진행 상태 영역
- **표시 방식**:
  - 각 단계별 예상 소요 시간을 실시간으로 계산하여 표시
  - 형식: `"정규화 중... (예상 소요 시간: 약 2분 30초)"`
  - 전체 진행률과 함께 남은 시간도 표시: `"진행률: 60% (남은 시간: 약 1분 20초)"`

#### 1.2.2 시간 계산 로직
- **초기 추정**: 첫 번째 청크 처리 시간을 측정하여 전체 청크 수를 곱해 예상 시간 계산
  - 예: 첫 청크 처리에 2초 소요, 전체 200개 청크 → 예상 시간: 400초 (약 6분 40초)
- **동적 업데이트**: 처리된 청크 수와 경과 시간을 기반으로 남은 시간을 실시간 업데이트
  - 공식: `남은 시간 = (경과 시간 / 처리된 청크 수) * 남은 청크 수`
  - 최소 3개 청크 이상 처리된 후부터 신뢰할 수 있는 추정치 제공
- **단계별 시간 추정**:
  - 텍스트 추출: PDF 크기에 비례 (1MB당 약 1-2초)
  - 청킹: 텍스트 길이에 비례 (10,000자당 약 0.5초)
  - 정규화: 청크 수에 비례 (LLM 호출 시간, 청크당 약 2-5초)
  - 임베딩 생성: 청크 수에 비례 (API 호출 시간, 청크당 약 0.5-1초)
- **표시 형식**: 
  - 1분 미만: "약 XX초"
  - 1분 이상: "약 X분 XX초"
  - 1시간 이상: "약 X시간 XX분"

#### 1.2.3 UI 구성
```
[Progress Bar: 60%]
정규화 중... (예상 소요 시간: 약 2분 30초)
처리된 청크: 120 / 200
```

---

## 2. API Key 입력 피드백 UI

### 2.1 현재 상태
- 사이드바에 API Key 입력 필드가 있음 (Gemini API Key, Tavily API Key)
- **문제점**: 입력 후 즉각적인 피드백이 없어 사용자가 키가 제대로 입력되었는지 확인하기 어려움

### 2.2 개선 요구사항

#### 2.2.1 입력 검증 및 피드백
- **트리거**: API Key 입력 필드에서 Enter 키를 누르거나 포커스를 잃을 때 (on_change 이벤트)
- **검증 로직**:
  1. 입력된 키가 비어있지 않은지 확인
  2. 키 형식이 유효한지 기본 검증 (길이, 문자 형식 등)
     - Gemini API Key: 일반적으로 "AIza..."로 시작, 최소 39자
     - Tavily API Key: 일반적으로 "tvly-..."로 시작
  3. 가능한 경우 실제 API 호출로 검증 (선택적, 비동기)
     - `LLMService.validate_api_key()` 메서드 활용
     - 검증은 백그라운드에서 수행하여 UI 블로킹 방지

#### 2.2.2 UI 피드백
- **성공 시**:
  - 초록색 배경의 알림 메시지 표시: `"✓ Gemini API Key가 입력되었습니다."`
  - 알림은 3초 후 자동으로 사라지거나 사용자가 닫을 수 있음
  - 입력 필드 아래에 `st.success()` 또는 `st.caption()`으로 상태 표시

- **실패 시**:
  - 빨간색 배경의 경고 메시지 표시: `"✗ 유효하지 않은 API Key입니다."`
  - 입력 필드 아래에 `st.error()` 또는 `st.caption()`으로 상태 표시

- **참고**: Streamlit의 `st.text_input`은 필드 옆에 직접 아이콘을 추가하기 어려우므로, 입력 필드 아래에 상태 메시지를 표시하는 방식 권장

#### 2.2.3 구현 위치
- **컴포넌트**: `component/sidebar.py`의 `render_sidebar()` 함수
- **Streamlit 위젯**: `st.success()`, `st.error()` 또는 커스텀 알림 컴포넌트 사용

---

## 3. 세션별 대화 데이터 다운로드 기능

### 3.1 현재 상태
- 세션별 대화 데이터는 `data/sessions/{session_id}/conversation.csv`에 저장됨
- **문제점**: 사용자가 웹 UI에서 직접 다운로드할 수 있는 기능이 없음

### 3.2 개선 요구사항

#### 3.2.1 다운로드 버튼 위치
- **위치**: Chat 탭 상단 또는 사이드바의 Session 섹션
- **표시 조건**: 현재 세션에 대화 기록이 있을 때만 표시

#### 3.2.2 다운로드 기능
- **버튼**: "📥 대화 내역 다운로드 (CSV)" 버튼
- **동작**:
  1. 현재 세션의 `conversation.csv` 파일을 읽어옴
  2. Streamlit의 `st.download_button`을 사용하여 다운로드 제공
  3. 파일명 형식: `conversation_{session_id}.csv`

#### 3.2.3 CSV 파일 구조
현재 저장되는 컬럼을 그대로 유지:
- `turn_id`: 턴 번호
- `role`: "user" 또는 "assistant"
- `content`: 메시지 내용
- `timestamp`: ISO 8601 형식 타임스탬프
- `input_tokens`: 입력 토큰 수
- `output_tokens`: 출력 토큰 수
- `model_used`: 사용된 모델명

#### 3.2.4 추가 고려사항
- 대화 기록이 없을 때는 버튼을 비활성화하거나 숨김
- 다운로드 시 사용자에게 알림 표시: `"대화 내역이 다운로드되었습니다."`

---

## 4. 세션 전환 시 대화 히스토리 초기화

### 4.1 현재 상태
- 사이드바에 세션 선택 드롭다운과 "Create New Session" 버튼이 있음
- 현재 `sidebar.py`에서는 새 세션 생성 시 세션 ID만 추가하고 `st.rerun()` 호출
- **문제점**:
  - 새 세션 생성 시 기존 대화 히스토리가 초기화되지 않음
  - 기존 세션 선택 시 해당 세션의 데이터를 로드하는 로직이 없음

### 4.2 개선 요구사항

#### 4.2.1 새 세션 생성 시
- **동작**: "Create New Session" 버튼 클릭 시
  1. 현재 세션 데이터 저장 (항목 7 참조)
  2. 모든 `st.session_state` 변수 초기화
  3. 새로운 세션 ID 생성 및 화면 새로고침

#### 4.2.2 기존 세션 선택 시
- **동작**: 드롭다운에서 기존 세션 선택 시
  1. 현재 세션 데이터 저장
  2. 선택된 세션의 데이터 로드 (항목 7 참조)
  3. 화면 새로고침

#### 4.2.3 세션 전환 감지
- `st.session_state.previous_session_id`를 사용하여 세션 변경 감지
- **구현 위치**: `app.py`의 `main()` 함수
- **구현 방법**:
  ```python
  previous_session = st.session_state.get("previous_session_id")
  current_session = st.session_state.current_session

  if previous_session != current_session:
      if previous_session:
          save_session_data(previous_session)
      load_session_data(current_session)
      st.session_state.previous_session_id = current_session
  ```

**참고**: 세션 데이터의 저장/로드 로직에 대한 상세 내용은 항목 7 참조

---

## 5. 메시지 상세 정보 확장 (툴 콜링 정보)

### 5.1 현재 상태
- Chat 탭에서 각 메시지의 "Details" expander에 모델명과 토큰 정보가 표시됨
- **문제점**: 툴 콜링이 발생했을 때 어떤 툴이 실행되었는지, 실행 과정이 어떻게 진행되었는지에 대한 정보가 표시되지 않음

### 5.2 개선 요구사항

#### 5.2.1 Details Expander 확장
- **기본 정보** (현재 유지):
  - Model: 사용된 모델명
  - Tokens: 입력/출력 토큰 수

- **추가 정보** (툴 콜링 발생 시):
  - **Tool Calls 섹션**: 실행된 툴 목록
    - 툴 이름
    - 툴 호출 인자 (arguments)
    - 툴 실행 결과 (result)
    - 실행 순서

#### 5.2.2 툴 콜링 정보 표시 형식
```
[Details] (expanded=False 기본값)

Model: gemini-2.5-flash
Tokens: 1,234 in / 567 out

Tool Calls (2):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
1. search_pdf_knowledge
   Arguments:
     - query: "AI 기술 동향"
     - top_k: 5
   Result: [관련 청크 5개 반환]

2. web_search
   Arguments:
     - query: "최신 AI 뉴스"
   Result: [웹 검색 결과 5개 반환]
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
```

#### 5.2.3 데이터 저장
- **현재 상태**: `app.py`의 `handle_chat_message()`에서 `result.get("function_calls")`로 툴 콜링 정보를 받아옴
- **개선 방안**:
  - `Message` 도메인 모델에 `function_calls` 필드 추가 (선택적, list 타입)
  - `assistant_msg` 생성 시 `function_calls` 정보 포함
  - `Message.to_dict()` 및 `Message.from_dict()`에 `function_calls` 필드 추가
- **데이터 구조**:
  ```python
  function_calls: list[dict] = field(default_factory=list)
  # 각 dict는 {"name": str, "args": dict, "result": Any} 형태
  ```
- **참고**: 현재 코드에서는 `function_calls`라는 키를 사용하지만, UI에서는 "Tool Calls"로 표시

#### 5.2.4 구현 위치
- **컴포넌트**: `component/chat_tab.py`의 `render_chat_tab()` 함수
  - 메시지 렌더링 루프에서 `msg.function_calls` (또는 `msg.tool_calls`) 확인
  - Details expander 내부에 Tool Calls 섹션 추가
- **데이터 구조**: `Message` 도메인 모델 확장
  - `domain/message.py`에 `function_calls` 필드 추가
  - `to_dict()`, `from_dict()` 메서드에 해당 필드 포함
- **데이터 흐름**:
  1. `app.py`의 `handle_chat_message()`에서 `result["function_calls"]` 수신
  2. `assistant_msg` 생성 시 `function_calls` 포함
  3. `ConversationRepository.append_message()`로 저장
  4. `chat_tab.py`에서 로드된 메시지의 `function_calls` 표시

---

## 6. Output Token 설정 기능 추가

### 6.1 현재 상태
- 사이드바의 Model Settings에 Temperature와 Top-p 슬라이더가 있음
- **문제점**: Output Token (max_output_tokens) 설정 옵션이 없음

### 6.2 개선 요구사항

#### 6.2.1 UI 추가
- **위치**: 사이드바의 Model Settings expander 내부
- **순서**: Temperature, Top-p 다음에 배치
- **컨트롤**: 슬라이더 또는 숫자 입력 필드

#### 6.2.2 설정 범위
- **슬라이더 옵션**:
  - 최소값: 256
  - 최대값: 65536 (Gemini 2.5 모델 기준, 모델별로 상이할 수 있음)
  - 기본값: 8192
  - 단위: tokens
  - 표시: "Max Output Tokens: 8192"
- **참고**: Gemini 2.5 Flash/Pro 모델은 최대 65,536 토큰까지 지원. 추후 모델 변경 시 최대값 조정 필요

#### 6.2.3 구현
- **컴포넌트**: `component/sidebar.py`의 Model Settings 섹션에 슬라이더 추가
  ```python
  max_output_tokens = st.slider(
      "Max Output Tokens",
      min_value=256,
      max_value=65536,
      value=8192,
      step=256,
  )
  ```

- **서비스**: `service/llm_service.py`의 `generate()` 메서드 수정
  ```python
  def generate(
      self,
      prompt: str,
      model: str | None = None,
      tools: list[Callable] | None = None,
      temperature: float = 0.7,
      top_p: float = 0.9,
      max_output_tokens: int = 8192,  # 추가
  ) -> dict:
      config = types.GenerateContentConfig(
          temperature=temperature,
          top_p=top_p,
          max_output_tokens=max_output_tokens,  # 추가
      )
      # ...
  ```

- **설정 전달**: `app.py`의 `handle_chat_message()`에서 설정값을 LLM 서비스에 전달

#### 6.2.4 주의사항
- Gemini API의 `GenerateContentConfig`에 `max_output_tokens` 옵션 포함
- 모델별 제한 확인 (일부 모델은 다른 최대값을 가질 수 있음)

---

## 7. 세션별 히스토리 완전 분리

### 7.1 현재 상태
- 세션 전환 기능은 있으나 실제로 히스토리가 분리되지 않음
- **문제점**: 세션을 바꿔도 같은 대화 히스토리가 표시됨

### 7.2 개선 요구사항

#### 7.2.1 세션별 독립적인 상태 관리
각 세션은 다음 정보를 독립적으로 관리해야 함:
- **대화 메시지** (`messages`)
- **토큰 사용량** (`token_usage`)
- **요약 정보** (`summary`)
- **PDF 청크** (`chunks`)
- **PDF 설명** (`pdf_description`)

#### 7.2.2 세션 전환 시 로드/저장 로직
- **현재 세션 저장** (세션 전환 전):
  1. `ConversationRepository.save_messages()` 호출하여 현재 메시지 저장
  2. 세션 메타데이터 파일(`metadata.json`)에 다음 정보 저장:
     - `token_usage`: 현재 토큰 사용량
     - `current_summary`: 현재 요약 정보
     - `last_updated`: 마지막 업데이트 시간
  3. PDF 청크는 `EmbeddingRepository`에 이미 저장되어 있으므로 별도 저장 불필요

- **새 세션 로드** (세션 선택 후):
  1. `ConversationRepository.load_messages()` 호출하여 대화 기록 로드
  2. `st.session_state.messages`에 로드된 메시지 설정
  3. 세션 메타데이터에서 토큰 사용량, 요약 정보 복원
  4. `EmbeddingRepository.load_chunks()`로 PDF 청크 로드 (있는 경우)
  5. `st.session_state.chunks`에 청크 설정
  6. `st.session_state.pdf_description` 복원 (메타데이터 또는 별도 파일에서)

- **세션별 메타데이터 파일 구조**:
  - 경로: `data/sessions/{session_id}/metadata.json`
  - 저장 주기: 세션 전환 시 또는 주기적으로 (예: 5턴마다)

#### 7.2.3 세션 상태 초기화
- **새 세션 생성 시**:
  - 모든 상태 변수를 초기값으로 설정
  - 빈 메시지 리스트, 0 토큰 사용량, 빈 요약 등

- **기존 세션 선택 시**:
  - 해당 세션의 저장된 데이터로 모든 상태 변수 설정

#### 7.2.4 구현 위치
- **주요 로직**: `app.py`의 `main()` 함수
- **세션 전환 감지**: `component/sidebar.py`에서 세션 변경 시 콜백 또는 상태 업데이트
- **데이터 로드/저장**: `repository/` 모듈 활용

#### 7.2.5 세션 메타데이터 구조 확장
- **파일 위치**: `data/sessions/{session_id}/metadata.json`
- **저장/로드**: `Session` 도메인 모델의 `to_dict()`, `from_dict()` 메서드 활용

- **현재 Session 도메인 구조** (`domain/session.py`):
```python
@dataclass
class Session:
    session_id: str
    created_at: str
    last_updated: str
    total_turns: int = 0
    current_summary: str = ""
    pdf_files: list[str] = field(default_factory=list)
    settings: dict  # model, temperature, top_p
```

- **확장이 필요한 필드**:
  - `token_usage: dict` - `{"input": int, "output": int, "total": int}`
  - `pdf_description: str` - PDF 문서 설명
  - `settings.max_output_tokens: int` - 항목 6 구현 시 추가

- **확장된 메타데이터 구조** (목표):
```json
{
  "session_id": "202601151430",
  "created_at": "2026-01-15T14:30:00",
  "last_updated": "2026-01-15T15:45:00",
  "total_turns": 12,
  "current_summary": "사용자는 AI 챗봇 개발에 대해 질문했으며...",
  "token_usage": {
    "input": 12450,
    "output": 8320,
    "total": 20770
  },
  "pdf_files": ["document1.pdf"],
  "pdf_description": "AI 기술 동향에 대한 보고서",
  "settings": {
    "model": "gemini-2.5-flash",
    "temperature": 0.7,
    "top_p": 0.9,
    "max_output_tokens": 8192
  }
}
```

- **구현 방법**:
  - `Session` 도메인 모델에 `token_usage`, `pdf_description` 필드 추가
  - `to_dict()`, `from_dict()` 메서드에 해당 필드 포함
  - 또는 별도의 `SessionRepository` 클래스 생성하여 메타데이터 저장/로드 담당
  - 저장 시점: 세션 전환 시, 또는 주기적으로 (예: 5턴마다)

---

## 8. Overview 탭 추가 (앱 설명서)

### 8.1 현재 상태
- 현재 앱에는 Chat 탭과 PDF Preprocessing 탭만 존재
- **문제점**: 앱 사용 방법, 기능 설명, 설정 가이드 등에 대한 문서가 없어 신규 사용자가 앱을 이해하고 사용하기 어려움

### 8.2 개선 요구사항

#### 8.2.1 탭 추가
- **위치**: 기존 Chat, PDF Preprocessing 탭과 함께 Overview 탭을 첫 번째 탭으로 추가
- **탭 순서**: Overview → Chat → PDF Preprocessing
- **아이콘**: 📖 또는 📚 아이콘 사용

#### 8.2.2 Overview 탭 구성
Overview 탭에는 다음 섹션들을 포함:

1. **앱 소개**
   - Gemini Hybrid Chatbot의 목적과 주요 기능
   - 하이브리드 AI 챗봇의 특징 (일반 모드 + 추론 모드)
   - RAG (Retrieval-Augmented Generation) 기능 설명

2. **시작하기 (Quick Start)**
   - API Key 설정 방법
   - 첫 대화 시작하기
   - PDF 업로드 및 전처리 방법

3. **주요 기능 설명**
   - **Chat 기능**:
     - 일반 대화 방법
     - PDF 기반 질의응답
     - 웹 검색 기능 (Tavily)
     - 모델 자동 전환 (Flash → Pro)
   - **PDF 전처리**:
     - PDF 업로드 및 텍스트 추출
     - 청킹 및 정규화
     - 임베딩 생성 및 벡터 검색
   - **세션 관리**:
     - 새 세션 생성
     - 세션 전환
     - 대화 내역 다운로드

4. **설정 가이드**
   - Model Settings 설명:
     - Chat Model 선택 (gemini-2.5-flash, gemini-2.5-pro 등)
     - Temperature 설정 (0.0 ~ 2.0)
     - Top-p 설정 (0.0 ~ 1.0)
     - Max Output Tokens 설정
   - External Search 설정:
     - Tavily 검색 활성화/비활성화
     - 검색 깊이 (basic/advanced)
     - 최대 결과 수

5. **고급 기능**
   - 툴 콜링 (Tool Calling) 설명
   - 컨텍스트 관리 및 요약 기능
   - 토큰 사용량 추적
   - 세션별 데이터 관리

6. **FAQ (자주 묻는 질문)**
   - API Key는 어디서 얻나요?
   - PDF 전처리는 왜 필요한가요?
   - 세션을 바꾸면 데이터가 사라지나요?
   - 토큰 제한은 어떻게 되나요?

7. **문제 해결 (Troubleshooting)**
   - 일반적인 오류 및 해결 방법
   - API Key 오류
   - PDF 업로드 실패
   - 메모리 부족 문제

#### 8.2.3 UI 구성
- **레이아웃**: 
  - 상단에 제목과 간단한 소개
  - 각 섹션은 `st.expander` 또는 `st.tabs`로 구성하여 접을 수 있게 함
  - 중요한 정보는 `st.info()`, `st.warning()`, `st.success()` 등으로 강조
- **스타일링**:
  - 마크다운 형식으로 작성하여 가독성 향상
  - 코드 블록은 적절히 사용
  - 스크린샷이나 다이어그램 포함 (선택적)

#### 8.2.4 구현 위치
- **컴포넌트**: `component/overview_tab.py` 새로 생성
- **함수**: `render_overview_tab()` 함수 구현
- **통합**: `app.py`의 `main()` 함수에서 탭 추가
  ```python
  # 항목 9(프롬프트 탭)와 함께 구현하는 경우
  tabs = st.tabs(["📖 Overview", "📝 Prompts", "💬 Chat", "📄 PDF Preprocessing"])

  with tabs[0]:
      render_overview_tab()
  ```
- **참고**: 프롬프트 탭(항목 9)과 함께 구현할 경우 탭 순서 조정 필요

#### 8.2.5 콘텐츠 관리
- **방법 1**: 컴포넌트 파일에 직접 마크다운 텍스트로 작성
- **방법 2**: 별도의 마크다운 파일(`doc/overview.md`)을 생성하고 읽어서 표시
- **권장**: 초기에는 컴포넌트 파일에 직접 작성, 나중에 필요시 외부 파일로 분리

#### 8.2.6 업데이트 관리
- 앱 기능이 변경되면 Overview 탭의 내용도 함께 업데이트
- 버전 정보 표시 (선택적)
- 마지막 업데이트 날짜 표시 (선택적)

---

## 9. 프롬프트 탭 추가 (프롬프트 안내)

### 9.1 현재 상태
- 앱에서 사용되는 모든 프롬프트가 코드에 하드코딩되어 있음
- **문제점**: 
  - 사용자가 어떤 프롬프트가 사용되고 있는지 알 수 없음
  - 프롬프트를 수정하려면 코드를 직접 수정해야 함
  - 프롬프트 관리가 어려움

### 9.2 개선 요구사항

#### 9.2.1 탭 추가
- **위치**: Overview 탭 다음에 추가
- **탭 순서**: Overview → 📝 Prompts → Chat → PDF Preprocessing
- **아이콘**: 📝 또는 ✏️ 아이콘 사용

#### 9.2.2 프롬프트 탭 구성
프롬프트 탭에는 다음 프롬프트들을 표시:

1. **시스템 프롬프트 (System Prompt)**
   - 기본 시스템 프롬프트 (일반 모드/추론 모드 설명)
   - PDF가 업로드된 경우 추가되는 PDF 관련 지시사항
   - 현재 세션에 적용된 시스템 프롬프트 표시

2. **요약 프롬프트 (Summary Prompt)**
   - 대화 요약 생성에 사용되는 프롬프트
   - 요약 규칙 및 형식 설명

3. **PDF 정규화 프롬프트 (PDF Normalization Prompt)**
   - PDF 청크 정규화에 사용되는 프롬프트
   - 정규화 규칙 설명

4. **PDF 설명 생성 프롬프트 (PDF Description Prompt)**
   - PDF 문서 설명 생성에 사용되는 프롬프트

5. **컨텍스트 빌드 로직**
   - 전체 프롬프트가 어떻게 구성되는지 설명
   - System Prompt + Summary + Recent Messages 구조

#### 9.2.3 UI 구성
- **레이아웃**:
  - 각 프롬프트는 `st.expander`로 구성하여 접을 수 있게 함
  - 프롬프트 내용은 `st.code()` 또는 `st.markdown()`으로 표시
  - 프롬프트 설명과 사용 시점을 함께 표시
- **표시 형식**:
  ```
  [System Prompt] (expanded=True 기본값)
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  사용 위치: 모든 대화에서 사용
  설명: AI의 동작 모드를 정의하고 툴 사용 지시사항을 포함
  
  프롬프트 내용:
  ```
  당신은 두 가지 모드로 동작합니다:
  1. 일반 모드: ...
  2. 추론 모드: ...
  ```
  ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  ```

#### 9.2.4 구현 위치
- **컴포넌트**: `component/prompts_tab.py` 새로 생성
- **함수**: `render_prompts_tab()` 함수 구현
- **프롬프트 로더**: `service/prompt_loader.py` 또는 `utils/prompt_loader.py` 생성
  - `prompt/` 디렉토리에서 프롬프트 파일들을 읽어옴
- **통합**: `app.py`의 `main()` 함수에서 탭 추가
  ```python
  tab0, tab1, tab2, tab3 = st.tabs([
      "📖 Overview", 
      "📝 Prompts", 
      "💬 Chat", 
      "📄 PDF Preprocessing"
  ])
  
  with tab1:
      render_prompts_tab()
  ```

#### 9.2.5 동적 프롬프트 표시
- 현재 세션 상태에 따라 실제 사용되는 프롬프트를 표시
- 예: PDF가 업로드된 경우 PDF 관련 지시사항이 포함된 시스템 프롬프트 표시
- 변수가 포함된 프롬프트는 실제 값으로 치환하여 표시

---

## 10. 프롬프트 파일 관리 시스템

### 10.1 현재 상태
- 모든 프롬프트가 코드에 하드코딩되어 있음
- **위치**:
  - `app.py`: 시스템 프롬프트, PDF 정규화 프롬프트, PDF 설명 프롬프트
  - `service/summary_service.py`: 요약 프롬프트
- **문제점**:
  - 프롬프트 수정 시 코드 수정 필요
  - 프롬프트 버전 관리 어려움
  - 프롬프트 재사용 불가

### 10.2 개선 요구사항

#### 10.2.1 디렉토리 구조 생성
- **디렉토리**: `prompt/` 루트에 생성
- **파일 구조**:
```
prompt/
├── system/
│   ├── base.txt              # 기본 시스템 프롬프트
│   └── pdf_extension.txt      # PDF 업로드 시 추가되는 지시사항
├── summary/
│   └── summary.txt            # 요약 프롬프트
├── pdf/
│   ├── normalization.txt      # PDF 정규화 프롬프트
│   └── description.txt        # PDF 설명 생성 프롬프트
└── templates/
    └── context_build.txt      # 컨텍스트 빌드 템플릿 (선택적)
```

#### 10.2.2 프롬프트 파일 형식
- **파일 형식**: `.txt` 파일 (마크다운 형식 지원)
- **템플릿 변수**: `{variable_name}` 형식으로 변수 사용
  - 예: `{pdf_description}`, `{previous_summary}`, `{chunk_text}` 등
- **주석**: `#` 또는 `<!-- -->` 형식으로 주석 지원 (선택적)

#### 10.2.3 프롬프트 로더 구현
- **클래스**: `PromptLoader` 또는 `PromptManager`
- **위치**: `service/prompt_loader.py` 또는 `utils/prompt_loader.py`
- **기능**:
  1. 프롬프트 파일 읽기
  2. 템플릿 변수 치환
  3. 프롬프트 캐싱 (성능 최적화)
  4. 프롬프트 검증

#### 10.2.4 구현 예시
```python
# service/prompt_loader.py
from pathlib import Path
from typing import Dict, Optional

class PromptLoader:
    def __init__(self, base_path: Path = Path("prompt")):
        self.base_path = base_path
        self._cache: Dict[str, str] = {}
    
    def load(self, category: str, filename: str) -> str:
        """프롬프트 파일 로드"""
        cache_key = f"{category}/{filename}"
        if cache_key in self._cache:
            return self._cache[cache_key]
        
        file_path = self.base_path / category / filename
        if not file_path.exists():
            raise FileNotFoundError(f"Prompt file not found: {file_path}")
        
        content = file_path.read_text(encoding="utf-8")
        self._cache[cache_key] = content
        return content
    
    def format(self, template: str, **kwargs) -> str:
        """템플릿 변수 치환"""
        return template.format(**kwargs)
    
    def get_system_prompt(self, pdf_description: Optional[str] = None) -> str:
        """시스템 프롬프트 가져오기"""
        base = self.load("system", "base.txt")
        if pdf_description:
            extension = self.load("system", "pdf_extension.txt")
            return f"{base}\n\n{self.format(extension, pdf_description=pdf_description)}"
        return base
```

#### 10.2.5 코드 리팩토링
- **app.py**:
  - `_get_system_prompt()` 함수를 `PromptLoader` 사용하도록 수정
  - PDF 정규화 프롬프트를 `PromptLoader`로 로드
  - PDF 설명 프롬프트를 `PromptLoader`로 로드

- **service/summary_service.py**:
  - `build_summary_prompt()` 메서드를 `PromptLoader` 사용하도록 수정

#### 10.2.6 프롬프트 파일 내용 예시

**prompt/system/base.txt**:
```
당신은 두 가지 모드로 동작합니다:
1. 일반 모드: 간단한 질문, 일상 대화, 정보 조회
2. 추론 모드: 복잡한 분석, 다단계 추론, 비교/평가, 수학적 계산

다음 상황에서는 반드시 switch_to_reasoning 툴을 호출하세요:
- 여러 정보를 종합하여 결론을 도출해야 할 때
- "왜", "어떻게", "비교해줘", "분석해줘" 등의 심층 질문
- PDF 내용을 기반으로 추론이 필요할 때
- 수학적 계산이나 논리적 단계가 필요할 때
```

**prompt/system/pdf_extension.txt**:
```
[업로드된 PDF 정보]
{pdf_description}
사용자가 이 문서와 관련된 질문을 하면 search_pdf_knowledge 툴을 사용하세요.
```

**prompt/summary/summary.txt**:
```
다음 대화 내용을 간결하게 요약하세요.
핵심 정보, 사용자의 요청 사항, 중요한 결정 사항을 포함해야 합니다.
200자 이내로 작성하세요.

이전 요약 (있는 경우):
{previous_summary}

추가할 대화:
{conversation}

통합 요약:
```

**prompt/pdf/normalization.txt**:
```
다음 텍스트를 검색에 최적화된 형태로 정규화하세요.
규칙:
1. 오탈자와 띄어쓰기 오류를 수정합니다.
2. 불필요한 특수문자와 중복 공백을 제거합니다.
3. 약어가 있다면 괄호 안에 풀이를 추가합니다.
4. 핵심 키워드는 그대로 유지합니다.
5. 원문의 의미를 변경하지 않습니다.

원본 텍스트:
{chunk_text}

정규화된 텍스트:
```

**prompt/pdf/description.txt**:
```
다음 문서 내용을 바탕으로 이 PDF 문서에 대한 간단한 설명(description)을 작성하세요.
50자 이내로 작성하세요.

문서 내용 샘플:
{sample_text}

설명:
```

#### 10.2.7 프롬프트 버전 관리
- 프롬프트 파일은 Git으로 버전 관리
- 프롬프트 변경 시 변경 이력 추적 가능
- 필요시 프롬프트 버전별 A/B 테스트 가능 (선택적)

#### 10.2.8 에러 처리
- 프롬프트 파일이 없을 경우 기본값(fallback) 사용 또는 에러 메시지 표시
- 템플릿 변수가 누락된 경우 명확한 에러 메시지
- 파일 인코딩 문제 처리 (UTF-8 강제)

---

## 구현 우선순위

1. **높음**: 세션별 히스토리 분리 (항목 4 + 7) - 핵심 기능
   - 항목 4: 세션 전환 UI 동작
   - 항목 7: 세션 데이터 저장/로드 로직 (항목 4의 기반)
2. **중간**:
   - 프롬프트 파일 관리 시스템 (항목 10) - 코드 리팩토링 필요
   - API Key 입력 피드백 (항목 2)
   - Output Token 설정 (항목 6)
   - Overview 탭 추가 (항목 8)
   - 프롬프트 탭 추가 (항목 9) - 항목 10 완료 후 구현 권장
3. **낮음**: PDF 진행 시간 표시 (항목 1), CSV 다운로드 (항목 3), 툴 콜링 상세 정보 (항목 5)

---

## 참고사항

- 모든 UI 변경사항은 Streamlit의 기본 컴포넌트를 우선 사용
- 사용자 경험을 고려하여 피드백은 즉각적이고 명확해야 함
- 세션 데이터는 안전하게 저장/로드되어야 하며, 데이터 손실이 발생하지 않아야 함 
