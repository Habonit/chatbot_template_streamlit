# Phase 03-2: Structured Output (Pydantic)

## 목표

현재 JSON 문자열 파싱 방식을 `model.with_structured_output(Pydantic)` 패턴으로 변경하여 안정적인 구조화 출력을 구현한다.

---

## 1. 현재 문제점

**파일**: `service/react_graph.py` (line 392-409)

```python
# 현재: 불안정한 JSON 문자열 파싱
try:
    result_text = content.strip()
    if "{" in result_text and "}" in result_text:
        json_start = result_text.find("{")
        json_end = result_text.rfind("}") + 1
        json_str = result_text[json_start:json_end]
        parsed = json.loads(json_str)
    else:
        parsed = json.loads(result_text)

    needs_more_tools = parsed.get("needs_more_tools", False)
    processor_summary = parsed.get("summary", "")
except (json.JSONDecodeError, AttributeError):
    # 파싱 실패 시 기본값
    needs_more_tools = False
    processor_summary = content
```

**문제점**:
- LLM이 JSON 외 텍스트를 함께 출력할 수 있음
- 키 이름이 달라질 수 있음
- 파싱 실패 시 기본값으로 처리 → 정확도 저하

---

## 2. Pydantic 모델 정의

### 2.1 새 파일 생성

**파일**: `domain/llm_output.py` (신규)

```python
"""LLM 구조화 출력을 위한 Pydantic 모델"""
from pydantic import BaseModel, Field
from typing import Literal, Optional


class ToolSelectorOutput(BaseModel):
    """Tool Selector 노드의 출력 스키마"""
    selected_tool: Literal[
        "get_current_time",
        "web_search",
        "search_pdf_knowledge",
        "reasoning",
        "none"
    ] = Field(
        description="다음에 실행할 도구. 도구가 필요 없으면 'none'"
    )
    reason: str = Field(
        description="도구 선택 이유 (한 문장)"
    )


class ResultProcessorOutput(BaseModel):
    """Result Processor 노드의 출력 스키마"""
    needs_more_tools: bool = Field(
        description="추가 도구 호출이 필요한지 여부"
    )
    summary: str = Field(
        description="현재까지 수집된 정보 요약"
    )
    next_action: Optional[str] = Field(
        default=None,
        description="추가 조사가 필요한 경우 다음 행동 제안"
    )


class ReasoningOutput(BaseModel):
    """Reasoning Tool의 출력 스키마"""
    thinking_steps: list[str] = Field(
        description="단계별 추론 과정"
    )
    conclusion: str = Field(
        description="최종 결론"
    )
    confidence: Literal["high", "medium", "low"] = Field(
        description="결론에 대한 확신도"
    )
```

### 2.2 domain/__init__.py 수정

**파일**: `domain/__init__.py`

**추가**:

```python
from domain.llm_output import (
    ToolSelectorOutput,
    ResultProcessorOutput,
    ReasoningOutput,
)

__all__ = [
    # 기존...
    "Message",
    "Chunk",
    "Session",
    # 추가
    "ToolSelectorOutput",
    "ResultProcessorOutput",
    "ReasoningOutput",
]
```

---

## 3. react_graph.py 수정

### 3.1 import 추가

```python
# 추가
from domain.llm_output import (
    ToolSelectorOutput,
    ResultProcessorOutput,
    ReasoningOutput,
)
```

### 3.2 structured LLM 인스턴스 생성

**`__init__` 메서드에 추가**:

```python
def __init__(self, ...):
    # 기존 코드...

    # 구조화 출력용 LLM 인스턴스 생성
    self._llm_tool_selector = self._llm.with_structured_output(
        schema=ToolSelectorOutput,
        method="json_schema"  # Gemini 네이티브 구조화 출력
    )

    self._llm_result_processor = self._llm.with_structured_output(
        schema=ResultProcessorOutput,
        method="json_schema"
    )
```

### 3.3 _tool_selector_node 수정

**기존 코드** (삭제):

```python
def _tool_selector_node(self, state: ChatState) -> dict:
    # ...
    content, in_tokens, out_tokens = self._invoke_llm_with_token_tracking(
        [HumanMessage(content=prompt)]
    )
    selected_tool = content.strip().lower()

    valid_tools = ["get_current_time", "web_search", "search_pdf_knowledge", "reasoning", "none"]
    if selected_tool not in valid_tools:
        selected_tool = "none"
    # ...
```

**수정 코드**:

```python
def _tool_selector_node(self, state: ChatState) -> dict:
    """Tool Selector 노드: 다음에 실행할 툴 선택 (Structured Output)"""
    tool_results_summary = ""
    if state.get("tool_results"):
        summaries = []
        for tool_name, result in state["tool_results"].items():
            summaries.append(f"[{tool_name}]: {result[:200]}...")
        tool_results_summary = "\n".join(summaries)

    prompt = get_tool_selector_prompt(
        user_input=state["user_input"],
        tool_history=state.get("tool_history", []),
        tool_results_summary=tool_results_summary,
        pdf_description=state.get("pdf_description", ""),
    )

    # Structured Output 사용
    response = self._llm_tool_selector.invoke([HumanMessage(content=prompt)])

    # 토큰 추적 (response_metadata에서 추출)
    in_tokens = 0
    out_tokens = 0
    if hasattr(response, "__dict__"):
        # Pydantic 모델은 response_metadata가 없으므로 별도 추적 필요
        pass  # 토큰 추적은 LangSmith에서 확인

    selected_tool = response.selected_tool

    return {
        "current_tool": selected_tool,
        "input_tokens": state.get("input_tokens", 0) + in_tokens,
        "output_tokens": state.get("output_tokens", 0) + out_tokens,
    }
```

### 3.4 _result_processor_node 수정

**기존 코드** (삭제):

```python
def _result_processor_node(self, state: ChatState) -> dict:
    # ...
    # JSON 파싱 시도
    try:
        result_text = content.strip()
        if "{" in result_text and "}" in result_text:
            json_start = result_text.find("{")
            json_end = result_text.rfind("}") + 1
            json_str = result_text[json_start:json_end]
            parsed = json.loads(json_str)
        else:
            parsed = json.loads(result_text)

        needs_more_tools = parsed.get("needs_more_tools", False)
        processor_summary = parsed.get("summary", "")
    except (json.JSONDecodeError, AttributeError):
        needs_more_tools = False
        processor_summary = content
    # ...
```

**수정 코드**:

```python
def _result_processor_node(self, state: ChatState) -> dict:
    """Result Processor 노드: 결과 해석 + 추가 툴 필요 여부 판단 (Structured Output)"""
    prompt = get_result_processor_prompt(
        user_input=state["user_input"],
        tool_history=state.get("tool_history", []),
        tool_results=state.get("tool_results", {}),
        iteration=state.get("iteration", 0),
        max_iterations=state.get("max_iterations", self.max_iterations),
    )

    # Structured Output 사용 - 파싱 실패 없음
    response = self._llm_result_processor.invoke([HumanMessage(content=prompt)])

    return {
        "needs_more_tools": response.needs_more_tools,
        "processor_summary": response.summary,
        "input_tokens": state.get("input_tokens", 0),
        "output_tokens": state.get("output_tokens", 0),
    }
```

---

## 4. 프롬프트 수정 (선택사항)

Structured Output 사용 시 프롬프트에서 JSON 형식 지시를 제거할 수 있다.

**파일**: `prompt/processor/result_processor.py`

**기존**:

```python
def get_prompt(...):
    return f"""
    ...
    반드시 아래 JSON 형식으로만 응답하세요:
    {{"needs_more_tools": true/false, "summary": "..."}}
    """
```

**수정**:

```python
def get_prompt(...):
    return f"""
    ...
    수집된 정보가 충분한지 판단하고, 추가 조사가 필요한지 결정하세요.
    """
    # JSON 형식 지시 제거 - Pydantic이 강제함
```

---

## 5. 변경 파일 요약

| 파일 | 변경 유형 | 내용 |
|------|----------|------|
| `domain/llm_output.py` | **신규** | Pydantic 출력 모델 정의 |
| `domain/__init__.py` | 수정 | 새 모델 export 추가 |
| `service/react_graph.py` | 수정 | with_structured_output 적용, JSON 파싱 코드 삭제 |
| `prompt/processor/result_processor.py` | 수정 | JSON 형식 지시 제거 (선택) |
| `prompt/selector/tool_selector.py` | 수정 | JSON 형식 지시 제거 (선택) |

---

## 6. 삭제되는 코드

**`service/react_graph.py`에서 삭제**:

```python
import json  # 더 이상 필요 없음 (다른 곳에서 사용하지 않는다면)

# _result_processor_node 내 JSON 파싱 로직 전체 (약 15줄)
try:
    result_text = content.strip()
    if "{" in result_text and "}" in result_text:
        # ...
except (json.JSONDecodeError, AttributeError):
    # ...
```

---

## 7. 테스트 계획

### 7.1 단위 테스트

**파일**: `tests/test_llm_output.py` (신규)

```python
import pytest
from domain.llm_output import ToolSelectorOutput, ResultProcessorOutput


def test_tool_selector_output_valid():
    output = ToolSelectorOutput(
        selected_tool="web_search",
        reason="최신 정보가 필요합니다"
    )
    assert output.selected_tool == "web_search"


def test_tool_selector_output_invalid_tool():
    with pytest.raises(ValueError):
        ToolSelectorOutput(
            selected_tool="invalid_tool",  # Literal에 없음
            reason="test"
        )


def test_result_processor_output():
    output = ResultProcessorOutput(
        needs_more_tools=True,
        summary="정보 수집 중"
    )
    assert output.needs_more_tools is True
    assert output.next_action is None  # Optional
```

### 7.2 통합 테스트

```python
def test_structured_output_integration():
    """실제 LLM 호출로 구조화 출력 확인"""
    graph = ReactGraphBuilder(api_key=os.getenv("GEMINI_API_KEY"))
    graph.build()

    result = graph.invoke("오늘 날씨 어때?", session_id="test")

    # tool_history가 리스트 형태로 정상 반환되는지 확인
    assert isinstance(result["tool_history"], list)
```

---

## 8. 참고: with_structured_output 메서드

```python
# method 옵션
# "json_schema" (기본값, 권장): Gemini 네이티브 구조화 출력
# "function_calling": 도구 호출 메커니즘 활용

model.with_structured_output(
    schema=PydanticModel,      # Pydantic 클래스
    method="json_schema",      # 권장
    include_raw=False,         # True면 원본 응답도 함께 반환
)
```
