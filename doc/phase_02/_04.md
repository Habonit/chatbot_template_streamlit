# Phase 02-4: ReAct + 노드별 프롬프트 분리 설계

## 1. 현재 구조의 문제점

```
현재: Agent 노드 하나가 모든 역할 수행 + 단일 프롬프트
┌─────────────────────────────────────────────┐
│                  Agent                      │
│  - 툴 선택 판단                              │
│  - 툴 결과 해석                              │  ← 하나의 프롬프트(agent.txt)로
│  - 추가 툴 필요 여부 판단                     │     모든 상황 처리
│  - 최종 응답 생성                            │
└─────────────────────────────────────────────┘
```

**문제**: 역할이 섞여서 프롬프트가 비대해지고, 각 단계별 세밀한 제어 불가

---

## 2. 새로운 구조: ReAct + 노드별 프롬프트

### 2.1 전체 흐름도

```
┌─────────────────────────────────────────────────────────────────────────────┐
│              ReAct + 노드별 프롬프트 구조                                    │
└─────────────────────────────────────────────────────────────────────────────┘

                         START
                           │
                           ▼
                  ┌─────────────────┐
                  │  Tool Selector  │ ◄── tool_selector.txt
                  │   (Agent 1)     │     "이 질문에 어떤 툴이 필요한가?"
                  └────────┬────────┘
                           │
              ┌────────────┼────────────┬────────────┐
              │            │            │            │
              ▼            ▼            ▼            ▼
         ┌────────┐  ┌────────┐  ┌────────┐  ┌────────┐
         │  Time  │  │  RAG   │  │ Search │  │Reasoning│
         │  Tool  │  │  Tool  │  │  Tool  │  │  Tool  │
         └────┬───┘  └────┬───┘  └────┬───┘  └────┬───┘
              │            │            │            │
           함수 실행    벡터 검색    API 호출    ◄── reasoning.txt
           (프롬프트X)  (프롬프트X)  (프롬프트X)      "단계별 추론"
              │            │            │            │
              └────────────┴────────────┴────────────┘
                                    │
                                    ▼
                           ┌─────────────────┐
                           │ Result Processor│ ◄── result_processor.txt
                           │   (Agent 2)     │     "결과 해석 + 추가 툴 필요?"
                           └────────┬────────┘
                                    │
                             ┌──────┴──────┐
                             │             │
                          더 필요        충분
                             │             │
                             │             ▼
                             │    ┌─────────────────┐
                             │    │Response Generator│ ◄── response_generator.txt
                             │    │   (Agent 3)      │     "최종 응답 형식화"
                             │    └────────┬────────┘
                             │             │
                             │             ▼
                             │           END
                             │
                             └──► Tool Selector로 돌아감 (ReAct 루프)
```

### 2.2 ReAct 루프 상세

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         ReAct 루프 동작 방식                                 │
└─────────────────────────────────────────────────────────────────────────────┘

[1회차]
┌─────────────┐     ┌─────────┐     ┌──────────────────┐
│Tool Selector│ ──► │  Tools  │ ──► │ Result Processor │
│ "검색 필요"  │     │web_search│     │ "결과 해석 완료.  │
└─────────────┘     └─────────┘     │  분석도 필요함"   │
                                    │  → 추가 툴 ✅    │
                                    └────────┬─────────┘
                                             │
                              ◄──────────────┘ (루프)

[2회차]
┌─────────────┐     ┌─────────┐     ┌──────────────────┐
│Tool Selector│ ──► │  Tools  │ ──► │ Result Processor │
│ "추론 필요"  │     │reasoning│     │ "분석 완료.      │
└─────────────┘     └─────────┘     │  이제 충분함"    │
                                    │  → 충분 ✅       │
                                    └────────┬─────────┘
                                             │
                                             ▼
                                    ┌──────────────────┐
                                    │Response Generator│
                                    │  최종 응답 생성   │
                                    └────────┬─────────┘
                                             │
                                             ▼
                                            END
```

---

## 3. 노드 구성

| 노드 | 타입 | 프롬프트 | 역할 |
|------|------|----------|------|
| **Tool Selector** | LLM Agent | `tool_selector.txt` | 다음에 실행할 툴 1개 선택 |
| **Time Tool** | 함수 | ❌ | `datetime.now()` 호출 |
| **RAG Tool** | 함수 | ❌ | 벡터 검색 실행 |
| **Search Tool** | 함수 | ❌ | Tavily API 호출 |
| **Reasoning Tool** | LLM | `reasoning.txt` | 단계별 추론 수행 |
| **Result Processor** | LLM Agent | `result_processor.txt` | 결과 해석 + 추가 툴 필요 여부 판단 |
| **Response Generator** | LLM Agent | `response_generator.txt` | 최종 응답 생성 |

---

## 4. 상태(State) 설계

```python
class ChatState(TypedDict):
    """ReAct 루프 전체에서 공유되는 상태"""

    # === 입력 ===
    user_input: str                   # 사용자 질문
    session_id: str                   # 세션 ID

    # === 컨텍스트 ===
    messages: list[BaseMessage]       # 대화 히스토리
    summary: str                      # 이전 대화 요약
    pdf_description: str              # 업로드된 PDF 설명

    # === ReAct 루프 상태 ===
    current_tool: str                 # 현재 선택된 툴 ("web_search", "reasoning", ...)
    tool_history: list[str]           # 지금까지 실행한 툴 목록
    iteration: int                    # 현재 반복 횟수
    max_iterations: int               # 최대 반복 횟수

    # === 툴 실행 결과 ===
    tool_results: dict[str, str]      # {"web_search": "결과...", "reasoning": "분석..."}

    # === 프로세서 판단 ===
    needs_more_tools: bool            # 추가 툴이 필요한가?
    processor_summary: str            # Result Processor의 중간 해석

    # === 최종 출력 ===
    final_response: str               # 최종 응답

    # === 메타데이터 ===
    input_tokens: int
    output_tokens: int
    model_used: str
```

---

## 5. 프롬프트 상세 설계

### 5.1 tool_selector.txt

```markdown
당신은 사용자 질문을 분석하여 **다음에 실행할 툴 하나**를 선택하는 전문가입니다.

## 사용 가능한 도구

| 도구 | 사용 조건 |
|------|----------|
| get_current_time | 현재 시각, 날짜, 오늘 관련 질문 |
| web_search | 최신 정보, 뉴스, 실시간 데이터, "검색해줘" |
| search_pdf_knowledge | "문서에서", "파일에", PDF 관련 질문 |
| reasoning | "왜", "어떻게", "비교", "분석", 복잡한 추론 |
| none | 더 이상 툴이 필요 없음 |

## 규칙

1. **한 번에 하나의 툴만** 선택하세요
2. 이미 실행한 툴은 다시 선택하지 마세요
3. PDF가 업로드되어 있으면 web_search보다 search_pdf_knowledge 우선
4. 충분한 정보가 모였으면 "none" 선택

## 현재 상태

- 사용자 질문: {user_input}
- 이미 실행한 툴: {tool_history}
- 현재까지 수집된 정보: {tool_results_summary}
- 업로드된 PDF: {pdf_description}

## 출력 형식

선택한 툴 이름만 출력 (따옴표 없이):
web_search
```

### 5.2 reasoning.txt

```markdown
당신은 복잡한 문제를 단계별로 분석하는 추론 전문가입니다.

## 추론 프로세스

### 1단계: 문제 분석
- 질문의 핵심 요구사항 파악
- 필요한 정보와 제약 조건 식별

### 2단계: 정보 수집 및 정리
- 주어진 컨텍스트에서 관련 정보 추출
- 부족한 정보 명시

### 3단계: 논리적 추론
- 수집한 정보를 바탕으로 논리적 단계 전개
- 각 단계의 근거 제시

### 4단계: 결론 도출
- 추론 결과 종합
- 결론의 타당성과 한계점 검토

## 입력 정보

[사용자 질문]
{user_input}

[참고 정보]
{context}

## 출력

위 단계를 따라 추론하고, 결론을 명확히 제시하세요.
```

### 5.3 result_processor.txt

```markdown
당신은 툴 실행 결과를 분석하고, 다음 행동을 결정하는 전문가입니다.

## 역할

1. **결과 해석**: 툴 실행 결과를 이해하고 요약
2. **충분성 판단**: 사용자 질문에 답하기에 충분한 정보가 모였는지 판단
3. **다음 행동 결정**: 추가 툴이 필요한지, 응답 생성으로 넘어갈지 결정

## 판단 기준

### 추가 툴이 필요한 경우
- 사용자 질문에 답하기에 정보가 부족함
- "분석해줘", "비교해줘" 요청이 있는데 reasoning을 안 했음
- 검색 결과가 불충분하거나 신뢰도가 낮음

### 충분한 경우
- 사용자 질문에 답할 수 있는 정보가 모두 모임
- 이미 필요한 모든 툴을 실행함
- 최대 반복 횟수에 도달

## 현재 상태

- 사용자 질문: {user_input}
- 실행한 툴: {tool_history}
- 툴 결과:
{tool_results}
- 반복 횟수: {iteration}/{max_iterations}

## 출력 형식

```json
{
  "summary": "현재까지 수집된 정보 요약 (2-3문장)",
  "needs_more_tools": true 또는 false,
  "reason": "판단 이유"
}
```
```

### 5.4 response_generator.txt

```markdown
당신은 수집된 정보를 바탕으로 최종 응답을 작성하는 전문가입니다.

## 응답 원칙

1. **구조화**: 번호 매기기, 소제목 사용
2. **충실한 답변**: 단답 금지, 이유와 배경 설명
3. **예시 포함**: 가능하면 구체적 예시 제공
4. **출처 언급**: 검색/문서에서 얻은 정보는 출처 명시

## 응답 길이

- 도구를 사용한 경우: 상세하고 충실한 답변
- 간단한 질문: 핵심만 간결하게

## 언어

- 한국어로 작성
- 전문 용어는 원어 병기 가능 (예: 머신러닝(Machine Learning))

## 입력 정보

[사용자 질문]
{user_input}

[수집된 정보]
{collected_info}

[Result Processor 요약]
{processor_summary}

## 출력

위 정보를 종합하여 구조화된 최종 응답을 작성하세요.
```

---

## 6. 프롬프트 파일 구조

```
prompt/
├── selector/
│   └── tool_selector.txt       # 툴 선택 (Agent 1)
├── tools/
│   └── reasoning.txt           # 추론 수행
├── processor/
│   └── result_processor.txt    # 결과 처리 + 루프 판단 (Agent 2)
└── response/
    └── response_generator.txt  # 최종 응답 생성 (Agent 3)
```

---

## 7. LangGraph 구현

```python
from langgraph.graph import StateGraph, START, END

def build_react_graph():
    builder = StateGraph(ChatState)

    # === 노드 추가 ===
    builder.add_node("tool_selector", tool_selector_node)
    builder.add_node("time_tool", time_tool_node)
    builder.add_node("rag_tool", rag_tool_node)
    builder.add_node("search_tool", search_tool_node)
    builder.add_node("reasoning_tool", reasoning_tool_node)
    builder.add_node("result_processor", result_processor_node)
    builder.add_node("response_generator", response_generator_node)

    # === 엣지: START → Tool Selector ===
    builder.add_edge(START, "tool_selector")

    # === 조건부 엣지: Tool Selector → 선택된 툴 ===
    builder.add_conditional_edges(
        "tool_selector",
        route_to_selected_tool,
        {
            "get_current_time": "time_tool",
            "search_pdf_knowledge": "rag_tool",
            "web_search": "search_tool",
            "reasoning": "reasoning_tool",
            "none": "response_generator",  # 툴 불필요 시 바로 응답
        }
    )

    # === 엣지: 각 툴 → Result Processor ===
    builder.add_edge("time_tool", "result_processor")
    builder.add_edge("rag_tool", "result_processor")
    builder.add_edge("search_tool", "result_processor")
    builder.add_edge("reasoning_tool", "result_processor")

    # === 조건부 엣지: Result Processor → 루프 or 응답 ===
    builder.add_conditional_edges(
        "result_processor",
        should_continue_loop,
        {
            "continue": "tool_selector",      # 추가 툴 필요 → 루프
            "finish": "response_generator",   # 충분 → 응답 생성
        }
    )

    # === 엣지: Response Generator → END ===
    builder.add_edge("response_generator", END)

    return builder.compile()


def route_to_selected_tool(state: ChatState) -> str:
    """Tool Selector가 선택한 툴로 라우팅"""
    return state["current_tool"]


def should_continue_loop(state: ChatState) -> str:
    """Result Processor 판단에 따라 루프 계속 or 종료"""
    if state["needs_more_tools"] and state["iteration"] < state["max_iterations"]:
        return "continue"
    return "finish"
```

---

## 8. 예시 흐름

### 질문: "파이썬 3.13 새 기능 검색해서 분석해줘"

```
┌─────────────────────────────────────────────────────────────────┐
│ [1회차]                                                         │
├─────────────────────────────────────────────────────────────────┤
│ Tool Selector                                                   │
│   입력: "파이썬 3.13 새 기능 검색해서 분석해줘"                    │
│   판단: "검색해서"가 있으니 web_search 필요                       │
│   출력: "web_search"                                            │
├─────────────────────────────────────────────────────────────────┤
│ Search Tool                                                     │
│   실행: Tavily API 호출                                         │
│   출력: "파이썬 3.13은 GIL 제거, 타입 힌트 개선..."              │
├─────────────────────────────────────────────────────────────────┤
│ Result Processor                                                │
│   입력: 검색 결과                                                │
│   판단: "분석해줘"가 있는데 reasoning 안 했음                     │
│   출력: {"needs_more_tools": true, "reason": "분석 요청 있음"}   │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ (루프)
┌─────────────────────────────────────────────────────────────────┐
│ [2회차]                                                         │
├─────────────────────────────────────────────────────────────────┤
│ Tool Selector                                                   │
│   입력: 질문 + 이미 실행한 툴 [web_search]                       │
│   판단: reasoning 필요                                          │
│   출력: "reasoning"                                             │
├─────────────────────────────────────────────────────────────────┤
│ Reasoning Tool                                                  │
│   실행: reasoning.txt 프롬프트로 LLM 호출                        │
│   출력: "1단계: 문제분석... 결론: GIL 제거가 가장 큰 변화..."     │
├─────────────────────────────────────────────────────────────────┤
│ Result Processor                                                │
│   입력: 검색 결과 + 추론 결과                                    │
│   판단: 검색도 했고 분석도 했음. 충분함                           │
│   출력: {"needs_more_tools": false, "reason": "충분한 정보"}     │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼ (종료)
┌─────────────────────────────────────────────────────────────────┐
│ Response Generator                                              │
├─────────────────────────────────────────────────────────────────┤
│   입력: 검색 결과 + 추론 결과 + Processor 요약                   │
│   실행: response_generator.txt 프롬프트로 LLM 호출               │
│   출력: 구조화된 최종 응답                                       │
│                                                                 │
│   "## 파이썬 3.13 주요 신기능                                    │
│                                                                 │
│    ### 1. GIL(Global Interpreter Lock) 제거                     │
│    - 멀티스레드 성능 대폭 향상...                                │
│                                                                 │
│    ### 2. 타입 힌트 개선                                        │
│    - ..."                                                       │
└─────────────────────────────────────────────────────────────────┘
                              │
                              ▼
                             END
```

---

## 9. 구현 체크리스트

- [ ] 프롬프트 파일 생성
  - [ ] `prompt/selector/tool_selector.txt`
  - [ ] `prompt/tools/reasoning.txt`
  - [ ] `prompt/processor/result_processor.txt`
  - [ ] `prompt/response/response_generator.txt`
- [ ] State 스키마 정의 (`ChatState`)
- [ ] 노드 함수 구현
  - [ ] `tool_selector_node`
  - [ ] `time_tool_node`
  - [ ] `rag_tool_node`
  - [ ] `search_tool_node`
  - [ ] `reasoning_tool_node`
  - [ ] `result_processor_node`
  - [ ] `response_generator_node`
- [ ] 라우팅 함수 구현
  - [ ] `route_to_selected_tool`
  - [ ] `should_continue_loop`
- [ ] 그래프 빌더 구현
- [ ] PromptLoader 확장 (새 디렉토리 구조 지원)
- [ ] 단위 테스트
- [ ] 통합 테스트

---

## 10. 기존 코드와의 차이점

| 항목 | 기존 (Phase 02-3) | 신규 (Phase 02-4) |
|------|-------------------|-------------------|
| 프롬프트 | `agent.txt` 1개 | 4개 (역할별 분리) |
| 툴 선택 | LLM이 tool_calls로 직접 | Tool Selector 노드 |
| 결과 처리 | Agent가 알아서 | Result Processor 노드 |
| 루프 판단 | tools_condition | should_continue_loop |
| 응답 생성 | Agent가 알아서 | Response Generator 노드 |

---

## 11. 프롬프트 패키지 구조 (.txt → .py)

### 11.1 변경 이유

| .txt 방식 | .py 방식 |
|-----------|----------|
| 별도 로더 필요 (`PromptLoader`) | `import`로 바로 사용 |
| IDE 자동완성 없음 | 자동완성 지원 |
| 런타임 파일 읽기 | 모듈 로드 (더 빠름) |
| 변수 치환 수동 | 함수로 캡슐화 |

### 11.2 새로운 프롬프트 구조

```
prompt/
├── __init__.py
├── selector/
│   ├── __init__.py
│   └── tool_selector.py        # TOOL_SELECTOR_PROMPT + get_prompt()
├── tools/
│   ├── __init__.py
│   └── reasoning.py            # REASONING_PROMPT + get_prompt()
├── processor/
│   ├── __init__.py
│   └── result_processor.py     # RESULT_PROCESSOR_PROMPT + get_prompt()
└── response/
    ├── __init__.py
    └── response_generator.py   # RESPONSE_GENERATOR_PROMPT + get_prompt()
```

### 11.3 프롬프트 모듈 예시

```python
# prompt/selector/tool_selector.py
"""툴 선택기 프롬프트"""

TOOL_SELECTOR_PROMPT = """
당신은 사용자 질문을 분석하여 **다음에 실행할 툴 하나**를 선택하는 전문가입니다.

## 사용 가능한 도구

| 도구 | 사용 조건 |
|------|----------|
| get_current_time | 현재 시각, 날짜, 오늘 관련 질문 |
| web_search | 최신 정보, 뉴스, 실시간 데이터, "검색해줘" |
| search_pdf_knowledge | "문서에서", "파일에", PDF 관련 질문 |
| reasoning | "왜", "어떻게", "비교", "분석", 복잡한 추론 |
| none | 더 이상 툴이 필요 없음 |

## 규칙

1. **한 번에 하나의 툴만** 선택하세요
2. 이미 실행한 툴은 다시 선택하지 마세요
3. PDF가 업로드되어 있으면 web_search보다 search_pdf_knowledge 우선
4. 충분한 정보가 모였으면 "none" 선택

## 현재 상태

- 사용자 질문: {user_input}
- 이미 실행한 툴: {tool_history}
- 현재까지 수집된 정보: {tool_results_summary}
- 업로드된 PDF: {pdf_description}

## 출력 형식

선택한 툴 이름만 출력 (따옴표 없이):
web_search
""".strip()


def get_prompt(
    user_input: str,
    tool_history: list[str],
    tool_results_summary: str = "",
    pdf_description: str = "",
) -> str:
    """툴 선택기 프롬프트 생성"""
    return TOOL_SELECTOR_PROMPT.format(
        user_input=user_input,
        tool_history=tool_history,
        tool_results_summary=tool_results_summary,
        pdf_description=pdf_description or "없음",
    )
```

### 11.4 사용 예시

```python
# service/react_graph.py
from prompt.selector.tool_selector import get_prompt as get_tool_selector_prompt
from prompt.tools.reasoning import get_prompt as get_reasoning_prompt

def tool_selector_node(state: ChatState) -> dict:
    prompt = get_tool_selector_prompt(
        user_input=state["user_input"],
        tool_history=state["tool_history"],
        tool_results_summary=summarize_results(state["tool_results"]),
        pdf_description=state["pdf_description"],
    )
    response = llm.invoke(prompt)
    return {"current_tool": response.content.strip()}
```

---

## 12. 구현 계획: 파일 변경 사항

### 12.1 삭제할 파일

| 파일 | 이유 |
|------|------|
| `prompt/system/agent.txt` | 단일 프롬프트 → 역할별 분리로 대체 |
| `prompt/system/base.txt` | 레거시 (Phase 01용) |
| `prompt/system/pdf_extension.txt` | 레거시 (Phase 01용) |
| `prompt/system/chain_of_thought.txt` | `reasoning.py`로 대체 |
| `prompt/search/tavily_instruction.txt` | `result_processor.py`에 통합 |
| `prompt/summary/summary.txt` | 미사용 |
| `service/chat_graph.py` | 레거시 (Phase 01용), `react_graph.py`로 대체 |
| `service/prompt_loader.py` | .py 프롬프트로 대체, 불필요 |

### 12.2 수정할 파일

| 파일 | 변경 내용 |
|------|----------|
| `service/react_chat_graph.py` | 전면 재작성 → `service/react_graph.py` |
| `service/tools.py` | 툴 함수만 유지, 팩토리 패턴 제거 |
| `app.py` | 새로운 `ReactGraph` 사용, State 초기화 변경 |
| `component/sidebar.py` | `max_iterations` 유지 |
| `tests/test_chat_graph.py` | 새로운 구조에 맞게 전면 재작성 |

### 12.3 새로 생성할 파일

| 파일 | 역할 |
|------|------|
| `prompt/__init__.py` | 프롬프트 패키지 초기화 |
| `prompt/selector/__init__.py` | |
| `prompt/selector/tool_selector.py` | 툴 선택 프롬프트 |
| `prompt/tools/__init__.py` | |
| `prompt/tools/reasoning.py` | 추론 프롬프트 |
| `prompt/processor/__init__.py` | |
| `prompt/processor/result_processor.py` | 결과 처리 프롬프트 |
| `prompt/response/__init__.py` | |
| `prompt/response/response_generator.py` | 최종 응답 프롬프트 |
| `service/react_graph.py` | 새로운 ReAct 그래프 (Phase 02-4) |
| `service/nodes.py` | 노드 함수들 (분리) |
| `tests/test_react_graph.py` | 새로운 테스트 |
| `tests/test_prompts.py` | 프롬프트 모듈 테스트 |

### 12.4 유지할 파일 (변경 없음)

| 파일 | 이유 |
|------|------|
| `prompt/pdf/normalization.txt` | PDF 전처리용, 별도 용도 |
| `prompt/pdf/description.txt` | PDF 전처리용, 별도 용도 |
| `service/embedding_service.py` | RAG 기능 유지 |
| `service/search_service.py` | 웹 검색 기능 유지 |
| `service/llm_service.py` | LLM 호출 유틸리티 |
| `repository/*` | 저장소 계층 유지 |
| `domain/*` | 도메인 모델 유지 |
| `component/chat_tab.py` | UI 컴포넌트 유지 |
| `component/pdf_tab.py` | UI 컴포넌트 유지 |

---

## 13. 구현 순서

```
Phase 02-4 구현 순서
━━━━━━━━━━━━━━━━━━━━

[1단계] 프롬프트 패키지 생성
├── prompt/__init__.py
├── prompt/selector/tool_selector.py
├── prompt/tools/reasoning.py
├── prompt/processor/result_processor.py
└── prompt/response/response_generator.py

[2단계] State 스키마 정의
└── service/react_graph.py (ChatState 클래스)

[3단계] 노드 함수 구현
├── service/nodes.py
│   ├── tool_selector_node
│   ├── time_tool_node
│   ├── rag_tool_node
│   ├── search_tool_node
│   ├── reasoning_tool_node
│   ├── result_processor_node
│   └── response_generator_node
└── 라우팅 함수 (route_to_selected_tool, should_continue_loop)

[4단계] 그래프 빌더 구현
└── service/react_graph.py (ReactGraphBuilder 클래스)

[5단계] app.py 연동
└── 새로운 ReactGraphBuilder 사용

[6단계] 테스트
├── tests/test_prompts.py (프롬프트 모듈)
├── tests/test_nodes.py (노드 함수)
├── tests/test_react_graph.py (그래프 통합)
└── tests/test_integration.py (실제 API)

[7단계] 정리
├── 레거시 파일 삭제
└── 문서 업데이트
```

---

## 14. 업데이트된 구현 체크리스트

### 14.1 프롬프트 패키지 (.py)
- [x] `prompt/__init__.py`
- [x] `prompt/selector/__init__.py`
- [x] `prompt/selector/tool_selector.py`
- [x] `prompt/tools/__init__.py`
- [x] `prompt/tools/reasoning.py`
- [x] `prompt/processor/__init__.py`
- [x] `prompt/processor/result_processor.py`
- [x] `prompt/response/__init__.py`
- [x] `prompt/response/response_generator.py`

### 14.2 서비스 계층
- [x] `service/react_graph.py` (ChatState + ReactGraphBuilder)
- [x] 노드 함수들 (`react_graph.py` 내부에 통합)
- [x] `service/tools.py` 유지 (기존 호환성)

### 14.3 앱 연동
- [x] `app.py` 수정 (ReactGraphBuilder 사용)

### 14.4 테스트
- [x] `tests/test_prompts.py` (18 tests)
- [x] `tests/test_react_graph.py` (23 tests)
- [x] `tests/test_integration.py` Phase 04 추가 (6 tests)

### 14.5 정리
- [x] 레거시 파일 유지 (기존 테스트 호환성)
- [x] `doc/phase_02/_04.md` 완료 표시

---

## 15. 테스트 결과 요약

| 테스트 파일 | 테스트 수 | 상태 |
|------------|----------|------|
| `test_prompts.py` | 18 | ✅ 통과 |
| `test_react_graph.py` | 23 | ✅ 통과 |
| `test_integration.py` (Phase 04) | 6 | ✅ 통과 |
| 기존 단위 테스트 | 160 | ✅ 통과 |
| **총합** | **201+** | ✅ |

### 통합 테스트 결과 (실제 API)

```
test_simple_question: 1 + 1 = 2 ✅
test_time_tool_invocation: get_current_time 호출 ✅
test_web_search_tool_invocation: web_search 호출 ✅
test_reasoning_tool_invocation: reasoning 호출 ✅
test_multiple_tools_sequential: web_search → reasoning (2회 루프) ✅
test_max_iterations_respected: max_iterations 존중 ✅
```
