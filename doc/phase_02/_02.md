# Phase 02-2: LangGraph 완전 전환

이 문서는 기존 `google-genai` 기반 구현을 `langchain-google-genai`로 완전 전환하고, LangGraph의 프리빌트 기능을 활용한 구조로 재설계합니다.

---

## 1. 목표

### 1.1 전환 목적
- `google-genai` → `langchain-google-genai` 완전 전환
- LangGraph의 `ToolNode`, `bind_tools()` 등 프리빌트 기능 활용
- 툴 노드 병렬 실행
- 프롬프트 체계적 관리

### 1.2 기대 효과
- LangChain 에코시스템 통합
- 코드 간결화 (프리빌트 노드 활용)
- 확장성 향상 (새 툴 추가 용이)

---

## 2. 패키지 변경

### 2.1 제거
```
google-genai
```

### 2.2 유지/추가
```
langchain-google-genai  # Gemini LLM
langchain               # 기본 프레임워크
langgraph               # 그래프 기반 워크플로우
```

### 2.3 영향받는 파일
| 파일 | 현재 | 변경 후 |
|------|------|---------|
| `service/llm_service.py` | `google.genai` | `langchain_google_genai.ChatGoogleGenerativeAI` |
| `service/embedding_service.py` | `google.genai` | `langchain_google_genai.GoogleGenerativeAIEmbeddings` |
| `service/chat_graph.py` | 커스텀 노드 | `ToolNode`, `bind_tools()` 활용 |

---

## 3. LangGraph 구조 재설계

### 3.1 전체 흐름
```
사용자 입력
    ↓
┌─────────────────────────────┐
│      agent (LLM + Tools)    │ ← model.bind_tools(tools)
│  모델이 tool_calls 결정     │
└─────────────────────────────┘
    ↓
    ├── tool_calls 있음 ──→ ToolNode (병렬 실행)
    │                            ↓
    │                       툴 결과 반환
    │                            ↓
    │                       agent (재호출)
    │                            ↓
    │                       (반복 또는 종료)
    │
    └── tool_calls 없음 ──→ 최종 응답
```

### 3.2 ReAct 패턴 적용
LangGraph의 ReAct 패턴을 사용하여 에이전트가 다음을 반복:
1. **Reasoning**: 어떤 툴을 사용할지 결정
2. **Acting**: 툴 실행
3. **Observation**: 결과 확인
4. 필요시 반복, 충분하면 최종 응답

### 3.3 노드 구성
| 노드 | 역할 | 구현 방식 |
|------|------|----------|
| `agent` | LLM 호출, 툴 선택/최종 응답 | `ChatGoogleGenerativeAI.bind_tools()` |
| `tools` | 선택된 툴 실행 | `langgraph.prebuilt.ToolNode` |

### 3.4 엣지 구성
```python
from langgraph.prebuilt import tools_condition

# agent → tools 또는 END
graph.add_conditional_edges(
    "agent",
    tools_condition,  # tool_calls 있으면 "tools", 없으면 END
)

# tools → agent (결과 전달 후 재평가)
graph.add_edge("tools", "agent")
```

---

## 4. 툴 정의

### 4.1 툴 목록
| 툴 이름 | 설명 | 구현 |
|--------|------|------|
| `get_current_time` | 현재 시각 (KST) | `@tool` 데코레이터 |
| `web_search` | Tavily 웹 검색 | `@tool` 데코레이터 |
| `search_pdf_knowledge` | PDF RAG 검색 | `@tool` 데코레이터 |

### 4.2 툴 정의 예시
```python
from langchain_core.tools import tool
from datetime import datetime
import pytz

@tool
def get_current_time() -> str:
    """현재 시각을 한국 시간(KST)으로 반환합니다. 사용자가 시간, 날짜, 오늘, 지금 등을 물어볼 때 사용합니다."""
    kst = pytz.timezone("Asia/Seoul")
    now = datetime.now(kst)
    return now.strftime("%Y-%m-%d %H:%M:%S") + " (KST)"

@tool
def web_search(query: str) -> str:
    """웹에서 최신 정보를 검색합니다. 실시간 정보, 뉴스, 최신 버전 등을 찾을 때 사용합니다."""
    # SearchService 호출
    ...

@tool
def search_pdf_knowledge(query: str) -> str:
    """업로드된 PDF 문서에서 관련 내용을 검색합니다. PDF, 문서 관련 질문에 사용합니다."""
    # EmbeddingService + EmbeddingRepository 호출
    ...
```

### 4.3 switch_to_reasoning 처리
기존 `switch_to_reasoning`은 툴이 아닌 **모델 전환 로직**으로 처리:
- 복잡한 질문 감지 시 `gemini-2.5-pro` 사용
- 시스템 프롬프트에서 처리하거나 별도 로직으로 분리

---

## 5. 프롬프트 관리

### 5.1 새로 추가할 프롬프트
| 파일 | 용도 |
|------|------|
| `prompt/system/agent.txt` | 에이전트 시스템 프롬프트 (툴 사용 가이드 포함) |

### 5.2 agent.txt 내용 예시
```
당신은 도움이 되는 AI 어시스턴트입니다.

사용 가능한 도구:
- get_current_time: 현재 시각이 필요할 때
- web_search: 최신 정보, 실시간 데이터가 필요할 때
- search_pdf_knowledge: 업로드된 PDF 문서에서 정보를 찾을 때

도구를 사용할 필요가 없다면 바로 답변하세요.
복잡한 분석이나 추론이 필요한 질문에는 단계별로 생각하세요.
```

### 5.3 Prompts 탭 업데이트
`component/prompts_tab.py`에 `agent.txt` 추가

---

## 6. 서비스 레이어 변경

### 6.1 LLMService 대체
```python
# 기존
from google import genai
client = genai.Client(api_key=api_key)
response = client.models.generate_content(...)

# 변경 후
from langchain_google_genai import ChatGoogleGenerativeAI
model = ChatGoogleGenerativeAI(model="gemini-2.0-flash", api_key=api_key)
response = model.invoke(messages)
```

### 6.2 EmbeddingService 대체
```python
# 기존
from google import genai
client = genai.Client(api_key=api_key)
result = client.models.embed_content(...)

# 변경 후
from langchain_google_genai import GoogleGenerativeAIEmbeddings
embeddings = GoogleGenerativeAIEmbeddings(model="text-embedding-004", api_key=api_key)
result = embeddings.embed_query(text)
```

### 6.3 ChatGraphBuilder 재구현
```python
from langgraph.graph import StateGraph, START, END
from langgraph.prebuilt import ToolNode, tools_condition
from langgraph.checkpoint.memory import MemorySaver
from langchain_google_genai import ChatGoogleGenerativeAI

class ChatGraphBuilder:
    def __init__(self, api_key: str, model: str = "gemini-2.0-flash"):
        self.llm = ChatGoogleGenerativeAI(model=model, api_key=api_key)
        self.tools = [get_current_time, web_search, search_pdf_knowledge]
        self.llm_with_tools = self.llm.bind_tools(self.tools)

    def build(self):
        builder = StateGraph(MessagesState)

        # 노드 추가
        builder.add_node("agent", self._call_model)
        builder.add_node("tools", ToolNode(self.tools))

        # 엣지 설정
        builder.add_edge(START, "agent")
        builder.add_conditional_edges("agent", tools_condition)
        builder.add_edge("tools", "agent")

        return builder.compile(checkpointer=MemorySaver())

    def _call_model(self, state):
        response = self.llm_with_tools.invoke(state["messages"])
        return {"messages": [response]}
```

---

## 7. 상태 스키마

### 7.1 MessagesState 사용
LangGraph 프리빌트 `MessagesState` 활용:
```python
from langgraph.graph import MessagesState

# MessagesState는 messages: list[BaseMessage] 포함
```

### 7.2 확장 상태 (필요시)
```python
from typing import Annotated
from langgraph.graph import MessagesState
import operator

class ChatState(MessagesState):
    summary: str                    # 누적 요약문
    summary_history: list[dict]     # 요약 히스토리
    pdf_description: str            # PDF 설명
```

---

## 8. app.py 통합

### 8.1 handle_chat_message 간소화
```python
def handle_chat_message(user_input: str, settings: dict, ...) -> dict:
    # 1. 그래프 생성
    graph_builder = ChatGraphBuilder(
        api_key=settings["gemini_api_key"],
        model=settings["model"],
    )
    graph = graph_builder.build()

    # 2. 메시지 준비
    messages = [HumanMessage(content=user_input)]

    # 3. 그래프 실행
    config = {"configurable": {"thread_id": session_id}}
    result = graph.invoke({"messages": messages}, config)

    # 4. 결과 반환
    return {
        "text": result["messages"][-1].content,
        ...
    }
```

---

## 9. 구현 순서

### Phase 1: 기반 전환
1. `langchain-google-genai`로 `LLMService` 대체
2. `langchain-google-genai`로 `EmbeddingService` 대체
3. 기존 테스트 업데이트

### Phase 2: 툴 정의
4. `@tool` 데코레이터로 툴 재정의
5. 툴 테스트 작성

### Phase 3: 그래프 재구현
6. `ChatGraphBuilder` 재구현 (ToolNode, tools_condition 활용)
7. ReAct 패턴 적용
8. 그래프 테스트 작성

### Phase 4: 통합
9. `app.py` 통합
10. 프롬프트 추가 (`prompt/system/agent.txt`)
11. Prompts 탭 업데이트
12. 전체 테스트

---

## 10. 테스트 계획

### 10.1 단위 테스트
- 각 툴 함수 테스트
- LLM 호출 모킹 테스트
- 그래프 노드/엣지 테스트

### 10.2 통합 테스트
- 전체 그래프 실행 테스트 (모킹)
- 툴 선택 → 실행 → 응답 흐름 테스트

---

## 11. 마이그레이션 체크리스트

- [x] `pyproject.toml`에서 `google-genai` 제거
- [x] `LLMService` → `ChatGoogleGenerativeAI` 전환 (`service/langchain_llm_service.py`)
- [x] `EmbeddingService` → `GoogleGenerativeAIEmbeddings` 전환 (`service/langchain_embedding_service.py`)
- [x] 툴 함수 `@tool` 데코레이터로 재정의 (`service/tools.py`)
- [x] `ChatGraphBuilder` 재구현 (`service/react_chat_graph.py` - `ReActChatGraphBuilder`)
- [x] `prompt/system/agent.txt` 추가
- [x] `prompts_tab.py` 업데이트
- [x] `app.py` 통합 (`ReActChatGraphBuilder` 사용)
- [x] 모든 테스트 통과 (148 passed)
